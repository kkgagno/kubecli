{% extends 'base.html' %}

{% block title %}Kubernetes Nodes{% endblock %}

{% block content %}
    <h1>Kubernetes Nodes</h1>
    <div class="d-flex justify-content-between align-items-center mb-3">
        <form class="row g-3 align-items-center" method="GET" action="{{ url_for('get_nodes') }}">
            <div class="col-auto">
                <label for="search" class="visually-hidden">Search</label>
                <input type="text" class="form-control" id="search" name="search" placeholder="Search by name" value="{{ search_query or '' }}">
            </div>
            <div class="col-auto">
                <button type="submit" class="btn btn-primary">Search</button>
            </div>
        </form>
        <div>
            <button type="button" class="btn btn-warning" id="cordon-selected">Cordon Options</button>
            <button type="button" class="btn btn-danger" id="drain-selected">Drain Selected</button>
            <button type="button" class="btn btn-success" id="uncordon-selected">Uncordon Selected</button>
            <button type="button" class="btn" id="patch-selected-security" style="background-color: #E65100; color: white;">Patch Selected (Security)</button>
            <button type="button" class="btn btn-warning" id="patch-selected-non-security">Patch Selected (Non-Security)</button>
            <span data-bs-toggle="tooltip" data-bs-placement="top" title="Must be cordoned to reboot">
                <button type="button" class="btn btn-danger" id="reboot-selected">Reboot Selected</button>
            </span>
            <button type="button" class="btn btn-secondary" id="refresh-data">Refresh Data</button>
        </div>
    </div>
    <table class="table table-striped">
        <thead>
            <tr>
                <th><input type="checkbox" id="select-all"></th>
                <th>Node Name</th>
                <th>Status</th>
                <th>Roles</th>
                <th>OS Image</th>
                <th>UPTIME</th>
                <th>Patch Status</th>
                <th>Reboot Required</th>
                <th>Informational</th>
            </tr>
        </thead>
        <tbody>
            {% for node in nodes %}
            <tr id="node-row-{{ node.name }}">
                <td><input type="checkbox" class="host-checkbox" data-hostname="{{ node.name }}"></td>
                <td>{{ node.name }}</td>
                <td>{{ node.status }}</td>
                <td>{{ node.roles }}</td>
                <td>{{ node.os_image }}</td>
                <td id="uptime-{{ node.name }}">
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    Checking...
                </td>
                <td id="patch-status-{{ node.name }}">
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    Checking...
                </td>
                <td id="reboot-required-{{ node.name }}">
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    Checking...
                </td>
                <td class="text-center" style="white-space: nowrap;">
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-info btn-sm" data-bs-toggle="modal" data-bs-target="#describeModal" data-url="{{ url_for('describe_resource', resource_type='node', namespace='-', name=node.name) }}" data-title="Describe Node: {{ node.name }}">
                            Describe
                        </button>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#describeModal" data-url="{{ url_for('get_updates', hostname=node.name, update_type='security') }}" data-title="Security Updates for {{ node.name }}">
                            Security Updates
                        </button>
                        <button type="button" class="btn btn-info btn-sm" data-bs-toggle="modal" data-bs-target="#describeModal" data-url="{{ url_for('get_updates', hostname=node.name, update_type='other') }}" data-title="Other Updates for {{ node.name }}">
                            Other Updates
                        </button>
                    </div>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <!-- Action Result Modal -->
    <div class="modal fade" id="actionResultModal" tabindex="-1" aria-labelledby="actionResultModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="actionResultModalLabel">Action Results</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body" id="actionResultModalBody">
            <!-- Results will be injected here -->
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Cordon Modal -->
    <div class="modal fade" id="cordonModal" tabindex="-1" aria-labelledby="cordonModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="cordonModalLabel">Cordon Options</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p>Choose a cordon option for the following nodes:</p>
            <ul id="cordon-nodes-list"></ul>
            <button type="button" class="btn btn-primary" id="cordon-only-btn">Cordon Only</button>
            <button type="button" class="btn btn-danger" id="cordon-drain-btn">Cordon and Drain</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <div class="modal fade" id="confirmationModal" tabindex="-1" aria-labelledby="confirmationModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="confirmationModalLabel">Confirm Action</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p id="confirmationModalText"></p>
            <ul id="confirmation-nodes-list"></ul>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="confirm-action-btn">Confirm</button>
          </div>
        </div>
      </div>
    </div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl)
    })

    const nodes = {{ nodes | tojson }};
    const cordonButton = document.getElementById('cordon-selected');
    const drainButton = document.getElementById('drain-selected');
    const uncordonButton = document.getElementById('uncordon-selected');
    const rebootButton = document.getElementById('reboot-selected');

    function updateButtonStates() {
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        if (selectedHosts.length === 0) {
            cordonButton.disabled = true;
            drainButton.disabled = true;
            uncordonButton.disabled = true;
            rebootButton.disabled = true;
            return;
        }

        let allSchedulable = true;
        let allUnschedulable = true;
        let anyReady = false;

        selectedHosts.forEach(hostname => {
            const node = nodes.find(n => n.name === hostname);
            if (node) {
                if (node.status.includes('SchedulingDisabled')) {
                    allSchedulable = false;
                } else {
                    allUnschedulable = false;
                    anyReady = true;
                }
            }
        });

        cordonButton.disabled = !allSchedulable;
        drainButton.disabled = anyReady || allSchedulable;
        uncordonButton.disabled = !allUnschedulable;
        rebootButton.disabled = anyReady;
    }

    document.querySelectorAll('.host-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', updateButtonStates);
    });

    document.getElementById('select-all').addEventListener('change', function(e) {
        document.querySelectorAll('.host-checkbox').forEach(checkbox => {
            checkbox.checked = e.target.checked;
        });
        updateButtonStates();
    });

    // Function to save selected hosts to sessionStorage
    function saveSelection() {
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        sessionStorage.setItem('selectedHosts', JSON.stringify(selectedHosts));
    }

    // Function to restore selection from sessionStorage
    function restoreSelection() {
        const selectedHosts = JSON.parse(sessionStorage.getItem('selectedHosts'));
        if (selectedHosts) {
            selectedHosts.forEach(hostname => {
                const checkbox = document.querySelector(`.host-checkbox[data-hostname="${hostname}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            updateButtonStates();
        }
    }

    // Restore selection on page load
    restoreSelection();
    updateButtonStates();

    document.getElementById('refresh-data').addEventListener('click', function() {
        saveSelection();
        location.reload();
    });

    document.getElementById('cordon-selected').addEventListener('click', function() {
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        if (selectedHosts.length === 0) {
            alert('Please select at least one host.');
            return;
        }
        const listElement = document.getElementById('cordon-nodes-list');
        listElement.innerHTML = '';
        selectedHosts.forEach(host => {
            const listItem = document.createElement('li');
            listItem.textContent = host;
            listElement.appendChild(listItem);
        });
        const cordonModal = new bootstrap.Modal(document.getElementById('cordonModal'));
        cordonModal.show();
    });

    document.getElementById('cordon-only-btn').addEventListener('click', function() {
        handleNodeAction('cordon_node_only', 'cordon');
        const cordonModal = bootstrap.Modal.getInstance(document.getElementById('cordonModal'));
        cordonModal.hide();
    });

    document.getElementById('cordon-drain-btn').addEventListener('click', function() {
        handleNodeAction('cordon_node', 'cordon and drain');
        const cordonModal = bootstrap.Modal.getInstance(document.getElementById('cordonModal'));
        cordonModal.hide();
    });

    document.getElementById('drain-selected').addEventListener('click', function() {
        showConfirmationModal('drain_node', 'drain');
    });

    document.getElementById('uncordon-selected').addEventListener('click', function() {
        showConfirmationModal('uncordon_node', 'uncordon');
    });

    document.getElementById('patch-selected-security').addEventListener('click', function() {
        showConfirmationModal('patch-security', 'patch security updates');
    });

    document.getElementById('patch-selected-non-security').addEventListener('click', function() {
        showConfirmationModal('patch-non-security', 'patch non-security updates');
    });

    document.getElementById('reboot-selected').addEventListener('click', function() {
        showConfirmationModal('reboot_selected', 'reboot');
    });

    function showConfirmationModal(action, verb) {
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        if (selectedHosts.length === 0) {
            alert('Please select at least one host.');
            return;
        }

        const modalText = document.getElementById('confirmationModalText');
        modalText.textContent = `Are you sure you want to ${verb} the following nodes?`;

        const listElement = document.getElementById('confirmation-nodes-list');
        listElement.innerHTML = '';
        selectedHosts.forEach(host => {
            const listItem = document.createElement('li');
            listItem.textContent = host;
            listElement.appendChild(listItem);
        });

        const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
        const confirmBtn = document.getElementById('confirm-action-btn');

        confirmBtn.onclick = function() {
            if (action.startsWith('patch')) {
                const patchType = action.substring('patch-'.length);
                patchSelected(patchType);
            } else if (action === 'reboot_selected') {
                rebootSelected();
            } else {
                handleNodeAction(action, verb);
            }
            confirmationModal.hide();
        };
        
        confirmationModal.show();
    }

    function handleNodeAction(action, verb) {
        saveSelection();
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        if (selectedHosts.length === 0) {
            alert('Please select at least one host.');
            return;
        }

        let results = [];
        Promise.all(selectedHosts.map(hostname => {
            return fetch(`/${action}/${hostname}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                results.push({hostname: hostname, data: data});
            });
        })).then(() => {
            const modalBody = document.getElementById('actionResultModalBody');
            let content = '';
            results.forEach(result => {
                content += `<h5>${result.hostname}</h5>`;
                content += `<p>${result.data.message}</p>`;
                if (result.data.evicted_pods && result.data.evicted_pods.length > 0) {
                    content += '<h6>Evicted Pods:</h6><ul>';
                    result.data.evicted_pods.forEach(pod => {
                        content += `<li>${pod}</li>`;
                    });
                    content += '</ul>';
                }
                if (result.data.ignored_pods && result.data.ignored_pods.length > 0) {
                    content += '<h6>Warning: Ignored Pods (DaemonSet-managed):</h6><ul>';
                    result.data.ignored_pods.forEach(pod => {
                        content += `<li>${pod}</li>`;
                    });
                    content += '</ul>';
                }
                if (result.data.errors && result.data.errors.length > 0) {
                    content += '<h6>Errors:</h6><ul>';
                    result.data.errors.forEach(error => {
                        content += `<li>${error}</li>`;
                    });
                    content += '</ul>';
                }
            });
            modalBody.innerHTML = content;
            const resultModal = new bootstrap.Modal(document.getElementById('actionResultModal'));
            resultModal.show();
            
            // Reload page when modal is closed
            document.getElementById('actionResultModal').addEventListener('hidden.bs.modal', function () {
                restoreSelection();
                location.reload();
            });
        }).catch(error => {
            console.error('Error:', error);
            alert(`An error occurred while performing the action.`);
        });
    }

    function rebootSelected() {
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        if (selectedHosts.length === 0) {
            alert('Please select at least one host.');
            return;
        }

        fetch('/reboot_selected', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ hosts: selectedHosts })
        })
        .then(response => response.json())
        .then(data => {
            alert(data.message);
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while rebooting the hosts.');
        });
    }

    function patchSelected(patchType) {
        const selectedHosts = Array.from(document.querySelectorAll('.host-checkbox:checked')).map(cb => cb.dataset.hostname);
        if (selectedHosts.length === 0) {
            alert('Please select at least one host.');
            return;
        }

        selectedHosts.forEach(hostname => {
            const statusCell = document.getElementById(`patch-status-${hostname}`);
            statusCell.innerHTML = '<span class="badge bg-info">Patching...</span>';
            fetch(`/run_patch/${hostname}/${patchType}`, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.task_id) {
                        pollTaskStatus(data.task_id, statusCell);
                    } else {
                        statusCell.innerHTML = '<span class="badge bg-danger">Error</span>';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    statusCell.innerHTML = '<span class="badge bg-danger">Error</span>';
                });
        });
    }

    function pollTaskStatus(taskId, statusCell) {
        const interval = setInterval(async () => {
            try {
                const response = await fetch(`/get_task_status/${taskId}`);
                const data = await response.json();

                if (data.status === 'completed') {
                    clearInterval(interval);
                    statusCell.innerHTML = '<span class="badge bg-success">Patched</span>';
                    const newWindow = window.open("", "_blank", "height=600,width=800");
                    let title = '';
                    if (data.patch_type === 'security') {
                        title = `Security patches for ${data.hostname}`;
                    } else if (data.patch_type === 'non-security') {
                        title = `Non-Security patches for ${data.hostname}`;
                    }
                    
                    if (title) {
                        newWindow.document.title = title;
                        newWindow.document.write(`<h1>${title}</h1><pre>${data.output}</pre>`);
                    } else {
                        newWindow.document.write("<pre>" + data.output + "</pre>");
                    }
                } else if (data.status === 'failed' || data.status === 'error') {
                    clearInterval(interval);
                    statusCell.innerHTML = '<span class="badge bg-danger">Error</span>';
                }
            } catch (error) {
                clearInterval(interval);
                statusCell.innerHTML = '<span class="badge bg-danger">Error</span>';
                console.error('Error polling task status:', error);
            }
        }, 5000);
    }

    function fetchNodeDetails(nodeName) {
        const uptimeCell = document.getElementById(`uptime-${nodeName}`);
        const patchStatusCell = document.getElementById(`patch-status-${nodeName}`);
        const rebootRequiredCell = document.getElementById(`reboot-required-${nodeName}`);
        const row = document.getElementById(`node-row-${nodeName}`);
        const rebootButton = row.querySelector('.reboot-button');

        fetch(`/get_node_details/${nodeName}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    uptimeCell.innerHTML = `<span class="badge bg-danger">Error</span>`;
                    patchStatusCell.innerHTML = `<span class="badge bg-danger">Error</span>`;
                    rebootRequiredCell.innerHTML = `<span class="badge bg-danger">Error</span>`;
                } else {
                    uptimeCell.textContent = data.uptime;
                    if (data.patch_status === 'Patches needed') {
                        patchStatusCell.innerHTML = `<span class="badge bg-danger">${data.patch_status}</span>`;
                    } else {
                        patchStatusCell.innerHTML = `<span class="badge bg-success">${data.patch_status}</span>`;
                    }
                    if (data.reboot_required) {
                        rebootRequiredCell.innerHTML = `<span class="badge bg-warning">Yes</span>`;
                    } else {
                        rebootRequiredCell.innerHTML = `<span class="badge bg-success">No</span>`;
                    }
                }
            })
            .catch(error => {
                console.error(`Error fetching details for ${nodeName}:`, error);
                uptimeCell.innerHTML = `<span class="badge bg-secondary">Error</span>`;
                patchStatusCell.innerHTML = `<span class="badge bg-secondary">Error</span>`;
                rebootRequiredCell.innerHTML = `<span class="badge bg-secondary">Error</span>`;
            });
    }

    nodes.forEach(node => {
        if (node.name) {
            fetchNodeDetails(node.name);
        }
    });

    var describeModal = document.getElementById('describeModal');
    if (describeModal) {
        describeModal.addEventListener('show.bs.modal', function (event) {
            var button = event.relatedTarget;
            var url = button.getAttribute('data-url');
            var title = button.getAttribute('data-title');
            var modalTitle = describeModal.querySelector('.modal-title');
            var modalBody = describeModal.querySelector('#modal-content-body');
            modalTitle.textContent = title;
            modalBody.innerHTML = '<div class="d-flex justify-content-center"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></div>';
            if (url) {
                fetch(url)
                    .then(response => {
                        if (response.status === 401) { window.location.href = "{{ url_for('login') }}"; return; }
                        if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                        const contentType = response.headers.get("content-type");
                        if (contentType && contentType.indexOf("application/json") !== -1) {
                            return response.json();
                        } else {
                            return response.text();
                        }
                    })
                    .then(data => {
                        if (typeof data === 'object' && data !== null) {
                            if(Array.isArray(data) && data.length > 0) {
                                let content = '<ul>';
                                data.forEach(item => {
                                    if(typeof item === 'object' && item !== null && 'name' in item) {
                                        content += `<li>${item.name} (New: ${item.new_version}, Current: ${item.current_version})</li>`;
                                    } else {
                                        content += `<li>${item}</li>`;
                                    }
                                });
                                content += '</ul>';
                                modalBody.innerHTML = content;
                            } else {
                                modalBody.textContent = 'No updates found.';
                            }
                        } else {
                            modalBody.textContent = data;
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching description:', error);
                        modalBody.textContent = 'Error loading content.';
                    });
            }
        });
    }

    // Clear selection when navigating away
    document.querySelectorAll('.sidebar a').forEach(link => {
        link.addEventListener('click', function() {
            sessionStorage.removeItem('selectedHosts');
        });
    });
});
</script>
{% endblock %}